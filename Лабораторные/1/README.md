<h1>Информация для защиты лабораторной работы #1</h1>

<h2>Список вопросов для защиты:</h2>
<ol>
  <li><a href="#1">База данных. Виды баз данных. СУБД.</a></li>
  <li><a href="#2">Архитектура ANSI-SPARC.</a></li>
  <li><a href="#3">Модель "Сущность-Связь". Классификация сущностей. Виды связей.</a></li>
  <li><a href="#4">Из каких подмножеств состоит SQL.</a></li>
  <li><a href="#5">DDL. Ключевые операторы. Примеры.</a></li>
  <li><a href="#6">DML. Ключевые операторы. Примеры.</a></li>
  <li><a href="#7">Что такое инфологическая и даталогическая модели бд.</a></li>
  <li><a href="#8">Что такое Primary Key, Foreign Key. Что такое потенциальный ключ.</a></li>
  <li><a href="#9">Плюсы и минусы использования суррогатных и естественных ключей. Cоставные ключи.</a></li>
  <li><a href="#10">Агрегатные и скалярные функции. Определение, примеры и особенности.</a></li>
  <li><a href="#11">Что такое отношение, атрибут, заголовок, тело, кортеж.</a></li>
  <li><a href="#12">CRUD.</a></li>
  <li><a href="#13">Отличия WHERE от HAVING. Группировка, сортировка данных.</a></li>
  <li><a href="#14">Типы данных. Плюсы и минусы использования типов данных хранящих большой диапазон значений.</a></li>
  <li><a href="#15">В чем отличие CHAR(), VARCHAR(), text.</a></li>
  <li><a href="#16">Ограничения целостности. CHECK, NOT NULL, UNIQUE, DEFAULT, PRIMARY KEY, FOREIGN KEY.</a></li>
  <li><a href="#17">DROP, DELETE, DROP/DELETE CASCADE, TRUNCATE().</a></li>
  <li><a href="#18">Последовательности. Тип SERIAL.</a></li>
  <li><a href="#19">Как можно выбрать уникальные значения. Как это сделать без использования DISTINCT.</a></li>
  <li><a href="#20">Какие операторы доступны в SQL. Примеры.</a></li>
  <li><a href="#21">Встроенные функции SQL. Примеры.</a></li>
  <li><a href="#22">ALIAS</a></li>
</ol>

<h2>Вопросы для саморазвития:</h2>
<ol>
  <li><a href="#001">Когда следует применять EMUM.</a></li>
  <li><a href="#002">Геометрические функции и операторы.</a></li>
  <li><a href="#003">generate_series</a></li>
  <li><a href="#004">Чем VARCHAR отличается от NVARCHAR?</a></li>
  <li><a href="#005">ALTER TABLE</a></li>
  <li><a href="#006">WAL</a></li>
  <li><a href="#007">Как скопировать данные из одной таблицы в другую?</a></li>
  <li><a href="#008">Что делают функции NVL и NVL2? Чем они отличаются?</a></li>
  <li><a href="#009">Оконные функции</a></li>
  <li><a href="#010">LIMIT, OFFSET, FETCH</a></li>
</ol>

<h2>Ответы на общие вопросы:</h2>
<h3 id="1">1. База данных. Виды баз данных. СУБД.</h3>
<p>В литературе предлагается множество определений понятия «база данных», отражающих скорее субъективное мнение тех или иных авторов, однако общепризнанная единая формулировка отсутствует.</p>
  
<blockquote>Система управления базами данных (СУБД) — это программный комплекс, обеспечивающий централизованное хранение данных и предоставляющий приложениям услуги по обработке данных.
Совокупность данных, хранимых под управлением СУБД, называется базой данных.
  
Источник: <a target="_blank" href="https://edu.postgrespro.ru/dbtech.pdf#page=20&zoom=100,76,409">Основы технологий баз данных (2020)</a></blockquote>

<blockquote>База данных — это файлы, снабжённые описанием хранимых в них данных 
и находящиеся под управлением специальных программных комплексов, 
называемых "Системы управления базами данных" (СУБД).
  
Источник: <a target="_blank" href="https://se.ifmo.ru/documents/10180/733702/isbd-2021-1.5.pdf/72944648-dbe7-ced4-38ac-35efe9f87e6f"> Университет ИТМО. Информационные системы и базы данных (2021)</a></blockquote>


Существует огромное количество разновидностей баз данных, различающихся по различным критериям.

<b>В классификацию по модели данных обычно включают:</b>
<ul>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">иерархические</a> - информация организована в виде иерархии или древовидной структуры.
  Примеры:IMS, ADABAS.</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">объектные или объектно-ориентированные - используют ОО модель данных.</a> 
    Пример — InterSystems Caché, Cerebrum</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">объектно-реляционные</a> и <a href="https://www.oracle.com/cis/database/what-is-a-relational-database/">реляционные</a> - используют реляционную модель данных (возможно, с частичной поддержкой ООП).
    Примеры — Oracle, PostgreSQL.</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">сетевые</a> - используют сетевую модель данных. Частный случай — графовые СУБД. 
    Примеры — HypergraphDB, OrientDB.</li>
  <li><a target="_blank" href="https://habr.com/ru/companies/lsfusion/articles/458774/">функциональные</a></li>
</ul>

<b>В классификацию СУБД по степени распределённости:</b>
<ul>
  <li>локальные (все части локальной СУБД размещаются на одном компьютере)</li>
  <li><a  target="_blank" href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85._%D0%A6%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B">распределённые</a> (части СУБД могут размещаться не только на одном, но на двух и более компьютерах)</li>
</ul>

<b>Классификацию СУБД способу доступа к БД.</b>
<ul>
  <li>Файл-серверные — данные находятся на файлсервере, СУБД — на каждом клиентском компьютере.
Примеры — M$ Access, dBase, FoxPro.</li>
  <li>Клиент-серверные — СУБД находятся на сервере
вместе с данными. Примеры — Oracle, M$ SQL
Server, Caché.</li>
  <li>Встраиваемые — СУБД встраивается в приложение,
хранит только его данные и не требует отдельной
установки. Примеры — SQLite, BerkeleyDB.</li>
</ul>

<a href="https://blog.skillfactory.ru/glossary/subd/"  target="_blank">Подробнее про СУБД</a><hr>

<h3 id="2">2. Архитектура ANSI-SPARC.</h3>

<blockquote>В 1975 г. комитетом CODASYL была подготовлена обобщенная модель языка описания данных. Описание этой модели стало известно под названием «модель данных ANSI/SPARC», так как предполагалось, что
  эта модель будет иметь статус стандарта. Схематически основные компоненты этой модели:<br><br>
  <p align="center"><img src="https://myfilology.ru/img_new/sparc.JPG"></p>
  Источник: <a target="_blank" href="https://edu.postgrespro.ru/dbtech.pdf#page=24&zoom=100,76,81">Основы технологий баз данных (2020)</a></blockquote>
</blockquote>

<ul>
  <li><b>внешнюю схему</b>, содержащую описание данных в таком виде, в котором они
    будут использоваться приложением (отдельно для каждого приложения),
    а также отображение логической структуры данных во внешнюю схему;
    </li>
  <li>
    <b>концептуальную схему</b>, содержащую полное описание логической структуры
данных, доступное СУБД (этот уровень описания было бы правильнее называть логической схемой базы данных);
  </li>
  <li>
    <b>схему хранения (внутреняя схема)</b>, описывающую, как организовано хранение логических структур данных.
  </li>
</ul>

Фактически эта модель никогда не была полностью реализована ни в одной системе, однако ее удобно использовать, для того чтобы определять назначение
тех или иных составляющих языка описания данных.

В идеале трехуровневая модель обеспечивает возможности относительно независимой эволюции приложений и системы в целом. Так, при появлении новых приложений, использующих те же данные, достаточно определить новую
внешнюю схему. В результате внедрение нового приложения не повлияет на
работу других приложений.

Если новая версия приложения использует дополнительные элементы или
структуры данных, достаточно определить новую внешнюю схему. Тогда старая
и новая версии приложения смогут сосуществовать, что значительно упрощает
постепенный и безопасный переход на новую версию.

Если для работы нового приложения требуются дополнительные структуры
данных, эти структуры могут быть добавлены в концептуальную схему, что теоретически не повлияет на работу других приложений, так как их внешние схемы не будут содержать новых элементов данных.<hr>


<h3 id="3">3. Модель "Сущность-Связь". Классификация сущностей. Виды связей.</h3>

Средствоммоделирования предметной области на этапе концептуального проектирования является модель "сущность–связь". Часто ее называют ER-моделью <b>(Entity - сущность, Relation- связь)</b> В ней моделирование структуры данных предметной области базируется на использовании графических средств – ER-диаграмм. В наглядном виде они представляют связь между сущностями.

* <b>Сущность</b> — класс объектов, фактов, явлений,
предметов, элементы которых будут храниться в базе
данных.
* <b>Экземпляр сущности</b> относится к конкретной вещи в
наборе. Например, типом сущности (сущностью) может
быть СТУДЕНТ , а экземпляром — Иван Иванов и т. д.
* <b>Атрибут</b> — важная характеристика (свойство)
сущности, которой присваивается имя.
* <b>Связь</b> — ассоциирование двух или более сущностей,
выражающая форму взаимодействия между ними.

<b>Классификация сущностей:</b>
* <b>Стержневые сущности (стержень)</b> — независимая, базовая сущность
* <b>Ассоциативная сущность (ассоциация)</b> — связь вида "многие-ко-многим" ("*-ко-многим" и т. д.) между двумя или более сущностями
* <b>Характеристическая сущность (характеристика)</b> — связь вида "многие-к-одной" или "одна-к-одной" между двумя сущностями (частный случай ассоциации). Цель характеристики - описание или уточнении некоторой другой сущности.


<b>Типы концов.</b>
<table>
  <tr>
    <th>Тип</th>
    <th>Обозначение</th>
  </tr>
  
  <tr>
    <td><p align="center">Один</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/9/93/Db_mandatory.png/50px-Db_mandatory.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Много</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/0/01/Db_many.png/50px-Db_many.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Обязательный</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/9/93/Db_mandatory.png/50px-Db_mandatory.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Необязательный</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/1/1a/Db_optional.png/50px-Db_optional.png"></p></td>
  </tr>
</table>
<details>
  <summary>Все виды концов связей.</summary>
  <img src="https://avatars.mds.yandex.net/get-lpc/1520633/9346286d-22db-439a-9ced-422fc163c2cd/width_480_q70"></a>
</details>


<b>Виды связей.</b>
<table>
  <tr>
    <th>Связь*</th>
    <th>Значение</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/e/e2/One_to_one.png/120px-One_to_one.png"></p></td>
    <td><p align="center">Один к одному</p></td>
     <td>В каждый момент времени каждому экземпляру первой
сущности соответствует 1 или 0 экземпляров второй
сущности</p></td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/5/50/One_to_many.png/120px-One_to_many.png"></p></td>
    <td><p align="center">Один ко многим</p></td>
    <td>Одному экземпляру первой сущности соответствуют 0, 1
или несколько экземпляров второй сущности;
Одному экземпляру второй сущности соответствует 0 или
1 экземпляров первой сущности</td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://i.ibb.co/XL8GCjS/120px-One-to-many-1.png"></p></td>
    <td>Многие к одному</td>
    <td><p align="center">Обратная связь к 1:М</p></td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/a/a4/Many_to_many.png/120px-Many_to_many.png"></p></td>
    <td><p align="center">Многие ко многим</p></td>
    <td>Одному экземпляру первой сущности соответствуют 0, 1
или несколько экземпляров второй сущности;
Одному экземпляру второй сущности соответствует 0, 1
или несколько экземпляров первой сущности
    </td>
  </tr>
  <tr><td colspan=3>* изображения типов концов связей приведены для примера</td></tr>
</table>

<b>Слабой сущностью</b> называется сущность, у которой недостаточно атрибутов для идентификации.

<b>Идентифицирующей связью</b> называется связь, позволяющая слабой сущности получить атрибуты, необходимые для ее идентификации.

<a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%81%D0%B2%D1%8F%D0%B7%D1%8C" target="_blank" >Подробнее</a><hr>

<h3 id="4">4. Из каких подмножеств состоит SQL.</h3>

<img src="https://1c-md.com/wp-content/webp-express/webp-images/doc-root/wp-content/uploads/2020/01/cbs-images-ff4bc89e-6b32-436d-b57a-bdbee58e1290.jpg.webp">

Про DDL смотреть <a href="#5">тут</a>.

Про DML смотреть <a href="#6">там</a>.

<b>Data Control Language (DCL)</b> - группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.

<b>Ключевые операторы:</b>
* GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
* REVOKE – отзывает выданные разрешения;
* DENY – задаёт запрет, имеющий приоритет над разрешением.
<a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/4#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B" target="_blank" >Подробнее</a>

Примеры:

<pre><code>GRANT INSERT ON my_table TO user;</code></pre>
<pre><code>REVOKE INSERT ON my_table TO user;</code></pre><hr>

<b>Transaction Control Language (TCL)</b> – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.

<b>Ключевые операторы:</b>
* BEGIN TRANSACTION – служит для определения начала транзакции;
* COMMIT TRANSACTION – применяет транзакцию;
* ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
* SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.

Пример:

<pre><code>BEGIN;
UPDATE my_table SET balance = balance - 100 WHERE used_id = 10;
UPDATE my_table SET balance = balance + 100 WHERE used_id = 20;
ROLLBACK
COMMIT;</code></pre>

<a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/3#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B" target="_blank" >Подробнее</a><hr>

<b>Data Query Language (DQL)</b> - выборка данных. Язык запросов DQL наиболее известен пользователям реляционной БД, несмотря на то, что он включает одну команду.

<b>Ключевые операторы:</b>
* SELECT - оператор запроса, который возвращающает определённый набор данных из базы данных. Список столбцов выборки задаётся в части оператора, которая называется предложением оператора SELECT.</b>

Примеры:

<pre><code>SELECT *
FROM students;</code></pre>
<pre><code>SELECT column1, column2, ...
FROM table_name;</code></pre>
<pre><code>SELECT DISTINCT students.name, students.surname
FROM students;</code></pre><hr>

<h3 id="5">5. DDL. Ключевые операторы. Примеры.</h3>

<b>Data Definition Language (DDL)</b> – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их.

<b>Ключевые операторы:</b>
* CREATE - создает объекты базы данных (таблицы, представления и т.д.)
* ALTER - Изменяет структуру и объекты базы данных
* DROP - Удаляет объекты базы данных
* TRUNCATE - Удаляет все записи из таблицы
* COMMENT - Добавляет комментарии в словарь данных
* RENAME - Переименовывает объект (alter table <old_name> rename to <new_name>)

Примеры:

<pre><code>CREATE TABLE IF NOT EXISTS table_name (
    user_id serial PRIMARY KEY,
    username VARCHAR ( 50 ) NOT NULL,
    last_login TIMESTAMP
);</code></pre>
<pre><code>ALTER TABLE old_table_name RENAME TO new_table_name;</code></pre><hr>


<h3 id="6">6. DML. Ключевые операторы. Примеры.</h3>

<b>Data Manipulation Language (DML)</b> – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.

<b>Ключевые операторы:</b>
* SELECT – выборка данных
* INSERT – вставка новых данных
* UPDATE – обновление данных
* DELETE – удаление данных
* MERGE – слияние данных

Примеры:

<pre><code>INSERT INTO Product
SET maker = 'B',
    model = 1157,
    type = 'PC';</code></pre>
<pre><code>INSERT INTO Product_D(maker, model, type) VALUES
('B', 1158, 'PC'),
('C', 2190, 'Laptop'),
('D', 3219, 'Printer');
</code></pre>

<hr><h3 id="7">7. Что такое инфологическая и даталогическая модели бд.</h3>

<b>Инфологическая модель:</b>
* обобщенное представление предметной области;
* собирается на основе анализа пользовательских представлений;
* не зависит от «физического» хранилища;
* есть стандартные средства для описания (например, ER-диаграмма);

Пример:
<p align="center"><img src="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/blob/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/1/%D0%98%D0%BD%D1%84%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png"></p>

<b>Даталогическая модель:</b>
* строится по инфологической модели 
* содержит структуру таблиц с указанием типов данных и связей между
таблицами
* учитывает реальные возможности организации данных средствами выбранной СУБД

Пример:
<p align="center"><img src="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/blob/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/1/%D0%94%D0%B0%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png"></p>

Для описания используется <a href="#3">модель "Сущность-Связь"</a>.

<b>Отображение ER-диаграмм в БД:</b>
* Сущность — таблица
* Экземпляр сущности — строка таблицы
* Атрибут — столбец в таблице
* Связь — внешний ключ, таблица
  
Связь «один-к-*»:
- Реализуется путем добавления в таблицу внешнего ключа.
- Внешний ключ обычно добавляется в сущностьассоциацию или в сущность-характеристику.
- Для моделирования характера связи на внешний ключ вводятся доп. ограничения (например, «один-кодному» - UNIQUE)

Связь «многие-ко-многим»:
- Для реализации связи вида «многие-ко-многим» создается вспомогательная таблица

Сайты для создания даталогических и инфологических моделей: 
* <a href="https://app.diagrams.net/" target="_blank">draw.io</a>
* <a href="https://dbdiagram.io/d" target="_blank">dbdiagram.io</a>

Как создать <a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5" target="_blank">даталогическую модель из DDL скрипта</a>.

<a href="https://ru.stackoverflow.com/questions/315124/%D0%9A%D0%B0%D0%BA-%D0%BE%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B8%D1%82%D1%8C-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-postgresql" target="_blank">Просмотр ER-диаграмм готовой бд.</a>

<hr><h3 id="8">8. Что такое Primary Key, Foreign Key. Что такое потенциальный ключ.</h3>

<b>Primary Key (PK, Первичный ключ)</b> - поле или набор полей со значениями, которые являются уникальными для всей таблицы.
- Ограничение первичного ключа эквивалентно комбинации ограничений UNIQUE и NOT NULL
- Таблица может иметь не более одного первичного ключа.
- Никакое поле нельзя удалить из ключа, неарушая при этом свойства однозначной идентификации записи (отсутствие избыточности)
- Добавление первичного ключа автоматически создает уникальный b-tree индекс на колонку (PostgreSQL)
- PostgreSQL позволяет не создавать первичный ключ для таблицы (согласно теории требуется наличие первичного ключа для каждой таблицы).

Примеры создания:
<pre><code>CREATE TABLE employees (
    employee_id serial PRIMARY KEY,
    first_name varchar(50),
    last_name varchar(50)
);</code></pre>

<pre><code>ALTER TABLE employees
ADD PRIMARY KEY (employee_id);
</code></pre>

<pre><code>CREATE TABLE orders (
    order_id serial,
    customer_id integer,
    order_date date,
    PRIMARY KEY (order_id, customer_id)
);</code></pre>

<pre><code>CREATE TABLE products (
    product_id serial,
    product_name varchar(100),
    CONSTRAINT pk_products PRIMARY KEY (product_id)
);</code></pre>


<b>Foreign Key (FK, Внешний ключ)</b> - столбец (или несколько столбцов), ссылающийся на первичный ключ другой таблицы.
- Если сущность связывает две другие сущности, то она должна включать внешние ключи, соответствующие первичным ключам связываемых сущностей.
- Если одна сущность характеризует другую сущность, то она должна включать внешний ключ, соответствующий первичному ключу первой сущности

Примеры создания:
<pre><code>CREATE TABLE Orders(
    Id SERIAL PRIMARY KEY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);</code></pre>

<pre><code>ALTER TABLE orders
ADD CONSTRAINT fk_customer
FOREIGN KEY (customer_id)
REFERENCES customers(ID);</code></pre>
<pre><code>CREATE TABLE orders (
    order_id serial PRIMARY KEY,
    customer_id integer REFERENCES customers(customer_id)
);
</code></pre>

<b>Candidate key (потенциальный ключ)</b> - представляет собой столбец (или несколько столбцов), которые могут стать первичным ключем, должны удовлетворять ряду условий:
- Неприводимость: он не может быть сокращен, он содержит минимально возможный набор атрибутов
- Уникальность (UNIQUE): он должен иметь уникальные значения вне зависимости от изменения строки
- Наличие значения (NOT NULL): он не должен иметь значения NULL, то есть он обязательно должен иметь значение.
Если у нас есть несколько потенциальных ключей, то те потенциальные ключи, которые не составляют первичный ключ, являются альтернативными ключами (alternative key).

<b>Особенности удаления FK.</b>

Внешние ключи существуют для обеспечения ссылочной целостности в базе данных. Это означает, что они гарантируют, что значения в столбце, связанном с внешним ключом, всегда ссылаются на существующие записи в связанной таблице. Поэтому удаление внешнего ключа может потребовать дополнительных действий для сохранения целостности данных.

При удалении записей из связанной таблицы, которые имеют связи через внешний ключ, СУБД может выполнить различные действия в зависимости от настроек внешнего ключа. Наиболее распространенные действия включают в себя:
- CASCADE: Удаление связанных записей в дочерней таблице, когда родительская запись удаляется.
- SET NULL: Установка значений в столбце с внешним ключом на NULL, когда родительская запись удаляется.
- SET DEFAULT: Установка значений в столбце с внешним ключом на значения по умолчанию, когда родительская запись удаляется.
- NO ACTION (RESTRICT): Запрещение удаления родительской записи, если существуют связанные записи в дочерней таблице.
Если вы планируете удалить запись из таблицы, учитывайте порядок операций. Сначала убедитесь, что вы удаляете записи из дочерних таблиц (если необходимо), а затем удаляйте запись из родительской таблицы. Это поможет избежать ошибок целостности данных.

Пример удаления FK:
<pre><code>ALTER TABLE orders
DROP CONSTRAINT fk_customer;
</code></pre>

Пример запроса который может вызвать ошибку ссылочной целостности по FK:
<pre><code>-- Попытаемся удалить клиента с активными заказами
DELETE FROM customers
WHERE customer_id = 1;
</code></pre>

<hr><h3 id="9">9. Плюсы и минусы использования суррогатных и естественных ключей. Cоставные ключи.</h3>

<b>Составной ключ</b> - представляет собой ключ, который состоит из двух или более атрибутов (полей), которые в совокупности однозначно идентифицируют записи в таблице.

<b>Суррогатный ключ</b> - это генерируемое системой (может быть GUID, последовательность, уникальный идентификатор и т.д.) значение, не имеющее смысла в терминах предметной области и которое используется для однозначной идентификации записи в таблице. Сам ключ может быть составлен из одного или большего числа столбцов (т.е. составной ключ). Пример: id.

<b>Естественный ключ</b> - это столбец или множество столбцов, которые уже существуют в таблице (например, это атрибуты сущности в модели данных) и однозначно идентифицируют запись в таблице. Поскольку эти столбцы являются атрибутами сущности, они очевидно имеют смысл в предметной области. Пример: Серия и номер паспорта, номер машины.

<b>Плюсы использования естественного ключа:</b>
- Значения ключа имеют смысл в предметной области и могут использоваться в качестве поискового ключа в запросах к таблице.
- Столбцы и индекс на первичном ключе уже существуют, поэтому не нужно дополнительного пространства на диске для дополнительного столбца/индекса, которые бы могли использоваться для суррогатного ключа.
- Меньше соединений таблиц, поскольку столбцы соединения имеют смысл. Например, это может уменьшить число дисковых операций ввода/вывода для выполнения избыточных чтений справочной таблицы.

<b>Минусы использования естественного ключа:</b>
- Может потребоваться поменять/переделать ключ, если изменятся бизнес-требования.
- Сложней обслуживать, если ключ состоит их нескольких столбцов. Со стороны приложений много проще работать с единственным ключевым столбцом
- Ухудшение производительности, поскольку значение ключа обычно больше по величине и/или состоит из нескольких столбцов. БОльшие ключи потребуют больше операций ввода/вывода при вставке/обновлении данных, а также при выборке.
- Нельзя ввести запись, если ключевое значение неизвестно. Приложениям иногда приходится загружать запись-заполнитель в одну таблицу, затем загружать в другие таблицы, после чего возвращаться и обновлять главную таблицу.
- Иногда трудно выбрать хороший ключ. Могут иметься несколько кандидатов для ключа, каждый со своими компромиссами с точки зрения проектирования и производительности.

<b>Плюсы использования сурогатного ключа:</b>
- Никакой бизнес-логики такой ключ не несет, поэтому нет никаких изменений, связанных с бизнес-требованиями.
- Меньше кода, если поддерживать одну и ту же стратегию ключа по всем сущностям. Например, код приложения может быть повторно использован при ссылках на первичные ключи, если все они применяют последовательное целое.
- Лучше производительность, поскольку ключ меньших размеров. Требуется меньшее число дисковых операций ввода/вывода при доступе к индексам на базе единственного столбца с точки зрения оптимизации.
- Суррогатный ключ гарантированно уникален. Например, при перемещении данных между тестовыми системами вам не придется беспокоиться о дубликатах ключей, поскольку новый ключ будет генерироваться при вставке данных
- Если использовалась последовательность, то потребуется минимальная поддержка индекса, поскольку значение монотонно возрастает, что приводит к меньшей фрагментации индекса.

<b>Минусы использования сурогатного ключа:</b>
- Дополнительный столбец (столбцы) на суррогатный ключ потребуют дополнительного места на диске.
- Дополнительный столбец (столбцы) на суррогатный ключ потребуют лишних операций ввода/вывода при вставке/обновлении данных.
- Потребуется больше соединений таблиц с дочерними таблицами, поскольку сами ключи не имеют смысла.
- Можно получить дубликаты естественного ключа в таблице, если отсутствуют другие ограничения уникальности на естественных ключах.
- Трудно различить тестовые и производственные данные. Например, поскольку значения суррогатного ключа являются просто автоматически генерируемыми и не имеющими отношения к предметной области, трудно сказать, взял ли кто-то производственные данные и загрузил их в тестовую среду.
- Ключевые значения не имеют отношения к данным, поэтому технически схема нарушает требования 3НФ (т.е. нормализацию).

<b>! Важно !</b>

Если у вас есть искусственный ключ и вы не объявляете естественные ключи, когда они существуют, то оставляете последние незащищёнными:
<pre><code>CREATE TABLE cars (
  car_id bigserial NOT NULL,
  vin varchar(17) NOT NULL,
  year int NOT NULL,

  UNIQUE (car_id)
  -- нужно было добавить
  -- UNIQUE (vin)
);

-- К сожалению, это успешно выполнится
INSERT INTO cars (vin, year) VALUES
  ('1FTJW36F2TEA03179', 1996),
  ('1FTJW36F2TEA03179', 1997);</code></pre>

<a href="https://habr.com/ru/companies/oleg-bunin/articles/348172/" target="_blank">Подробнее про ключи</a>


<hr><h3 id="10">10. Агрегатные и скалярные функции. Определение, примеры и особенности.</h3>
<b>Агрегатные функции</b> - выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение.
Агрегатные функции часто используются с операторами GROUP BY и HAVING. Оператор GROUP BY группирует строки с одинаковыми значениями в одну строку. Оператор HAVING используется в качестве фильтра для запросов, в которых есть оператор GROUP BY.
С агрегатными функциями можно использовать ключевые слова DISTINCT и ALL.

Свойства агрегатных функций:
- <b>Игнорируют NULL-значения.</b> Исключение — функция COUNT(*).
- Все агрегатные функции детерминированы. Это значит, что для одинакового набора данных функции возвращают одинаковое значение.

Примеры:
- SUM(column): вычисляет сумму значений столбца
- MIN(column): вычисляет наименьшее значение
- MAX(column): вычисляет наибольшее значение
- AVG(column): вычисляет среднее значение
- COUNT(column): вычисляет количество строк в запросе

Примеры в SQL:
<pre><code>SELECT role, COUNT(*) number_of_empoyee FROM employees GROUP BY role;
</code></pre>
<pre><code>SELECT SUM(salary) AS total_salary FROM employees;</code></pre>

<b>Скалярные функции</b> - принимают на вход одно значение и возвращают одно значение, но применяются к каждой строке.
Примеры:
- ABS(x): возвращает абсолютное значение числа x.
- ROUND(x, d): округляет число x до d знаков после запятой.
- CAST(expression AS data_type): преобразует выражение в указанный тип данных.
- RANDOM(): возвращает случайное число между 0 и 1
- UPPER(str): преобразует строку str в верхний регистр.

Примеры в SQL:
<pre><code>
</code></pre>
<pre><code>SELECT SUM(salary) AS total_salary FROM employees;</code></pre>


<hr><h3 id="11">11. Что такое отношение, атрибут, заголовок, тело, кортеж.</h3>
<p align="center"><img src="https://i.ibb.co/9ncv4hD/2.png"></p>

<b>Отношение (Relation, Имя таблицы)</b>: 

В реляционных базах данных отношение - это абстрактное представление таблицы, которая хранит данные. Отношение состоит из строк и столбцов. Каждая строка представляет собой запись, а каждый столбец определяет атрибут, описывающий определенные характеристики данных.

<b>Атрибут (Attribute, Колонка, Столбец)</b>: 

Атрибут представляет собой столбец в отношении (таблице). Каждый атрибут определяет конкретное свойство или характеристику, которая хранится в отношении. Например, в таблице "Пользователи" атрибуты могут включать "Имя", "Возраст", "Электронная почта" и так далее.

<b>Заголовок (Header)</b>: 

Заголовок отношения - это первая строка или метаданные в таблице, которая содержит имена атрибутов (столбцов). Заголовок помогает идентифицировать, какие атрибуты содержатся в таблице и какие типы данных они могут хранить.

<b>Тело (Body)</b>: 

Тело таблицы (отношения) состоит из фактических данных, представленных в виде строк и столбцов. Каждая строка в теле таблицы содержит конкретную запись или кортеж, где каждый атрибут имеет свое значение.

<b>Кортеж (Tuple, Строка)</b>: 

Кортеж - это термин, используемый в контексте реляционных баз данных для обозначения одной записи или строки в отношении. Каждый кортеж содержит набор значений, соответствующих атрибутам таблицы.

<hr><h3 id="12">12. </h3>
<hr><h3 id="13">13. </h3>
<hr><h3 id="14">14. </h3>
<hr><h3 id="15">15. </h3>
<hr><h3 id="16">16. </h3>
<hr><h3 id="17">17. </h3>
<hr><h3 id="18">18. </h3>
<hr><h3 id="19">19. </h3>
<hr><h3 id="20">20. </h3>
<hr><h3 id="21">21. </h3>
<hr><h3 id="22">22. </h3>


