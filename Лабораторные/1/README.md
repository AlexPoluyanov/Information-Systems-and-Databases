<h1>Информация для защиты лабораторной работы #1</h1>

<h2>Список вопросов для защиты:</h2>
<ol>
  <li><a href="#1">База данных. Виды баз данных. СУБД.</a></li>
  <li><a href="#2">Архитектура ANSI-SPARC.</a></li>
  <li><a href="#3">Модель "Сущность-Связь". Классификация сущностей. Виды связей.</a></li>
  <li><a href="#4">Из каких подмножеств состоит SQL.</a></li>
  <li><a href="#5">DDL. Ключевые операторы. Примеры.</a></li>
  <li><a href="#6">DML. Ключевые операторы. Примеры.</a></li>
  <li><a href="#7">Что такое инфологическая и даталогическая модели бд.</a></li>
  <li><a href="#8">Что такое Primary Key, Foreign Key. Что такое потенциальный ключ.</a></li>
  <li><a href="#9">Плюсы и минусы использования суррогатных и естественных ключей. Cоставные ключи.</a></li>
  <li><a href="#10">Агрегатные и скалярные функции. Определение, примеры и особенности.</a></li>
  <li><a href="#11">Что такое отношение, атрибут, заголовок, тело, кортеж.</a></li>
  <li><a href="#12">CRUD.</a></li>
  <li><a href="#13">Отличия WHERE от HAVING. Группировка, сортировка данных.</a></li>
  <li><a href="#14">Типы данных. Плюсы и минусы использования типов данных хранящих большой диапазон значений.</a></li>
  <li><a href="#15">В чем отличие CHAR(), VARCHAR(), text.</a></li>
  <li><a href="#16">Ограничения целостности. CHECK, NOT NULL, UNIQUE, DEFAULT, PRIMARY KEY, FOREIGN KEY.</a></li>
  <li><a href="#17">DROP, DELETE, DROP/DELETE CASCADE, TRUNCATE().</a></li>
  <li><a href="#18">Последовательности. Тип SERIAL.</a></li>
  <li><a href="#19">Как можно выбрать уникальные значения. Как это сделать без использования DISTINCT.</a></li>
  <li><a href="#20">Какие операторы доступны в SQL. Примеры.</a></li>
  <li><a href="#21">Встроенные функции SQL. Примеры.</a></li>
  <li><a href="#22">ALIAS</a></li>
</ol>

<h2>Вопросы для саморазвития:</h2>
<ol>
  <li><a href="#001">Когда следует применять EMUM.</a></li>
  <li><a href="#002">Геометрические функции и операторы.</a></li>
  <li><a href="#003">generate_series</a></li>
  <li><a href="#004">Чем VARCHAR отличается от NVARCHAR?</a></li>
  <li><a href="#005">ALTER TABLE</a></li>
  <li><a href="#006">WAL</a></li>
  <li><a href="#007">Как скопировать данные из одной таблицы в другую?</a></li>
  <li><a href="#008">Что делают функции NVL и NVL2? Чем они отличаются?</a></li>
  <li><a href="#009">Оконные функции</a></li>
  <li><a href="#010">LIMIT, OFFSET, FETCH</a></li>
</ol>

<h2>Ответы на общие вопросы:</h2>
<h3 id="1">1. База данных. Виды баз данных. СУБД.</h3>
<p>В литературе предлагается множество определений понятия «база данных», отражающих скорее субъективное мнение тех или иных авторов, однако общепризнанная единая формулировка отсутствует.</p>
  
<blockquote>Система управления базами данных (СУБД) — это программный комплекс, обеспечивающий централизованное хранение данных и предоставляющий приложениям услуги по обработке данных.
Совокупность данных, хранимых под управлением СУБД, называется базой данных.
  
Источник: <a target="_blank" href="https://edu.postgrespro.ru/dbtech.pdf#page=20&zoom=100,76,409">Основы технологий баз данных (2020)</a></blockquote>

<blockquote>База данных — это файлы, снабжённые описанием хранимых в них данных 
и находящиеся под управлением специальных программных комплексов, 
называемых "Системы управления базами данных" (СУБД).
  
Источник: <a target="_blank" href="https://se.ifmo.ru/documents/10180/733702/isbd-2021-1.5.pdf/72944648-dbe7-ced4-38ac-35efe9f87e6f"> Университет ИТМО. Информационные системы и базы данных (2021)</a></blockquote>


Существует огромное количество разновидностей баз данных, различающихся по различным критериям.

<b>В классификацию по модели данных обычно включают:</b>
<ul>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">иерархические</a> - информация организована в виде иерархии или древовидной структуры.
  Примеры:IMS, ADABAS.</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">объектные или объектно-ориентированные - используют ОО модель данных.</a> 
    Пример — InterSystems Caché, Cerebrum</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">объектно-реляционные</a> и <a href="https://www.oracle.com/cis/database/what-is-a-relational-database/">реляционные</a> - используют реляционную модель данных (возможно, с частичной поддержкой ООП).
    Примеры — Oracle, PostgreSQL.</li>
  <li><a target="_blank" href="https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">сетевые</a> - используют сетевую модель данных. Частный случай — графовые СУБД. 
    Примеры — HypergraphDB, OrientDB.</li>
  <li><a target="_blank" href="https://habr.com/ru/companies/lsfusion/articles/458774/">функциональные</a></li>
</ul>

<b>В классификацию СУБД по степени распределённости:</b>
<ul>
  <li>локальные (все части локальной СУБД размещаются на одном компьютере)</li>
  <li><a  target="_blank" href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85._%D0%A6%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B">распределённые</a> (части СУБД могут размещаться не только на одном, но на двух и более компьютерах)</li>
</ul>

<b>Классификацию СУБД способу доступа к БД.</b>
<ul>
  <li>Файл-серверные — данные находятся на файлсервере, СУБД — на каждом клиентском компьютере.
Примеры — M$ Access, dBase, FoxPro.</li>
  <li>Клиент-серверные — СУБД находятся на сервере
вместе с данными. Примеры — Oracle, M$ SQL
Server, Caché.</li>
  <li>Встраиваемые — СУБД встраивается в приложение,
хранит только его данные и не требует отдельной
установки. Примеры — SQLite, BerkeleyDB.</li>
</ul>

<a href="https://blog.skillfactory.ru/glossary/subd/"  target="_blank">Подробнее про СУБД</a><hr>

<h3 id="2">2. Архитектура ANSI-SPARC.</h3>

<blockquote>В 1975 г. комитетом CODASYL была подготовлена обобщенная модель языка описания данных. Описание этой модели стало известно под названием «модель данных ANSI/SPARC», так как предполагалось, что
  эта модель будет иметь статус стандарта. Схематически основные компоненты этой модели:<br><br>
  <p align="center"><img src="https://myfilology.ru/img_new/sparc.JPG"></p>
  Источник: <a target="_blank" href="https://edu.postgrespro.ru/dbtech.pdf#page=24&zoom=100,76,81">Основы технологий баз данных (2020)</a></blockquote>
</blockquote>

<ul>
  <li><b>внешнюю схему</b>, содержащую описание данных в таком виде, в котором они
    будут использоваться приложением (отдельно для каждого приложения),
    а также отображение логической структуры данных во внешнюю схему;
    </li>
  <li>
    <b>концептуальную схему</b>, содержащую полное описание логической структуры
данных, доступное СУБД (этот уровень описания было бы правильнее называть логической схемой базы данных);
  </li>
  <li>
    <b>схему хранения (внутреняя схема)</b>, описывающую, как организовано хранение логических структур данных.
  </li>
</ul>

Фактически эта модель никогда не была полностью реализована ни в одной системе, однако ее удобно использовать, для того чтобы определять назначение
тех или иных составляющих языка описания данных.

В идеале трехуровневая модель обеспечивает возможности относительно независимой эволюции приложений и системы в целом. Так, при появлении новых приложений, использующих те же данные, достаточно определить новую
внешнюю схему. В результате внедрение нового приложения не повлияет на
работу других приложений.

Если новая версия приложения использует дополнительные элементы или
структуры данных, достаточно определить новую внешнюю схему. Тогда старая
и новая версии приложения смогут сосуществовать, что значительно упрощает
постепенный и безопасный переход на новую версию.

Если для работы нового приложения требуются дополнительные структуры
данных, эти структуры могут быть добавлены в концептуальную схему, что теоретически не повлияет на работу других приложений, так как их внешние схемы не будут содержать новых элементов данных.<hr>


<h3 id="3">3. Модель "Сущность-Связь". Классификация сущностей. Виды связей.</h3>

Средствоммоделирования предметной области на этапе концептуального проектирования является модель "сущность–связь". Часто ее называют ER-моделью <b>(Entity - сущность, Relation- связь)</b> В ней моделирование структуры данных предметной области базируется на использовании графических средств – ER-диаграмм. В наглядном виде они представляют связь между сущностями.

* <b>Сущность</b> — класс объектов, фактов, явлений,
предметов, элементы которых будут храниться в базе
данных.
* <b>Экземпляр сущности</b> относится к конкретной вещи в
наборе. Например, типом сущности (сущностью) может
быть СТУДЕНТ , а экземпляром — Иван Иванов и т. д.
* <b>Атрибут</b> — важная характеристика (свойство)
сущности, которой присваивается имя.
* <b>Связь</b> — ассоциирование двух или более сущностей,
выражающая форму взаимодействия между ними.

<b>Классификация сущностей:</b>
* <b>Стержневые сущности (стержень)</b> — независимая, базовая сущность
* <b>Ассоциативная сущность (ассоциация)</b> — связь вида "многие-ко-многим" ("*-ко-многим" и т. д.) между двумя или более сущностями
* <b>Характеристическая сущность (характеристика)</b> — связь вида "многие-к-одной" или "одна-к-одной" между двумя сущностями (частный случай ассоциации). Цель характеристики - описание или уточнении некоторой другой сущности.


<b>Типы концов.</b>
<table>
  <tr>
    <th>Тип</th>
    <th>Обозначение</th>
  </tr>
  
  <tr>
    <td><p align="center">Один</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/9/93/Db_mandatory.png/50px-Db_mandatory.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Много</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/0/01/Db_many.png/50px-Db_many.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Обязательный</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/9/93/Db_mandatory.png/50px-Db_mandatory.png"></p></td>
  </tr>
  <tr>
    <td><p align="center">Необязательный</p></td>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/1/1a/Db_optional.png/50px-Db_optional.png"></p></td>
  </tr>
</table>
<details>
  <summary>Все виды концов связей.</summary>
  <img src="https://avatars.mds.yandex.net/get-lpc/1520633/9346286d-22db-439a-9ced-422fc163c2cd/width_480_q70"></a>
</details>


<b>Виды связей.</b>
<table>
  <tr>
    <th>Связь*</th>
    <th>Значение</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/e/e2/One_to_one.png/120px-One_to_one.png"></p></td>
    <td><p align="center">Один к одному</p></td>
     <td>В каждый момент времени каждому экземпляру первой
сущности соответствует 1 или 0 экземпляров второй
сущности</p></td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/5/50/One_to_many.png/120px-One_to_many.png"></p></td>
    <td><p align="center">Один ко многим</p></td>
    <td>Одному экземпляру первой сущности соответствуют 0, 1
или несколько экземпляров второй сущности;
Одному экземпляру второй сущности соответствует 0 или
1 экземпляров первой сущности</td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://i.ibb.co/XL8GCjS/120px-One-to-many-1.png"></p></td>
    <td>Многие к одному</td>
    <td><p align="center">Обратная связь к 1:М</p></td>
  </tr>
  <tr>
    <td><p align="center"><img src="https://neerc.ifmo.ru/wiki/images/thumb/a/a4/Many_to_many.png/120px-Many_to_many.png"></p></td>
    <td><p align="center">Многие ко многим</p></td>
    <td>Одному экземпляру первой сущности соответствуют 0, 1
или несколько экземпляров второй сущности;
Одному экземпляру второй сущности соответствует 0, 1
или несколько экземпляров первой сущности
    </td>
  </tr>
  <tr><td colspan=3>* изображения типов концов связей приведены для примера</td></tr>
</table>

<b>Слабой сущностью</b> называется сущность, у которой недостаточно атрибутов для идентификации.

<b>Идентифицирующей связью</b> называется связь, позволяющая слабой сущности получить атрибуты, необходимые для ее идентификации.

<a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%81%D0%B2%D1%8F%D0%B7%D1%8C" target="_blank" >Подробнее</a><hr>

<h3 id="4">4. Из каких подмножеств состоит SQL.</h3>

<img src="https://1c-md.com/wp-content/webp-express/webp-images/doc-root/wp-content/uploads/2020/01/cbs-images-ff4bc89e-6b32-436d-b57a-bdbee58e1290.jpg.webp">

Про DDL смотреть <a href="#5">тут</a>.

Про DML смотреть <a href="#6">там</a>.

<b>Data Control Language (DCL)</b> - группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.

<b>Ключевые операторы:</b>
* GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
* REVOKE – отзывает выданные разрешения;
* DENY – задаёт запрет, имеющий приоритет над разрешением.
<a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/4#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B" target="_blank" >Подробнее</a>

Примеры:

<pre><code>GRANT INSERT ON my_table TO user;</code></pre>
<pre><code>REVOKE INSERT ON my_table TO user;</code></pre><hr>

<b>Transaction Control Language (TCL)</b> – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.

<b>Ключевые операторы:</b>
* BEGIN TRANSACTION – служит для определения начала транзакции;
* COMMIT TRANSACTION – применяет транзакцию;
* ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
* SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.

Пример:

<pre><code>BEGIN;
UPDATE my_table SET balance = balance - 100 WHERE used_id = 10;
UPDATE my_table SET balance = balance + 100 WHERE used_id = 20;
ROLLBACK
COMMIT;</code></pre>

<a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/3#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B" target="_blank" >Подробнее</a><hr>

<b>Data Query Language (DQL)</b> - выборка данных. Язык запросов DQL наиболее известен пользователям реляционной БД, несмотря на то, что он включает одну команду.

<b>Ключевые операторы:</b>
* SELECT - оператор запроса, который возвращающает определённый набор данных из базы данных. Список столбцов выборки задаётся в части оператора, которая называется предложением оператора SELECT.</b>

Примеры:

<pre><code>SELECT *
FROM students;</code></pre>
<pre><code>SELECT column1, column2, ...
FROM table_name;</code></pre>
<pre><code>SELECT DISTINCT students.name, students.surname
FROM students;</code></pre><hr>

<h3 id="5">5. DDL. Ключевые операторы. Примеры.</h3>

<b>Data Definition Language (DDL)</b> – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их.

<b>Ключевые операторы:</b>
* CREATE - создает объекты базы данных (таблицы, представления и т.д.)
* ALTER - Изменяет структуру и объекты базы данных
* DROP - Удаляет объекты базы данных
* TRUNCATE - Удаляет все записи из таблицы
* COMMENT - Добавляет комментарии в словарь данных
* RENAME - Переименовывает объект (alter table <old_name> rename to <new_name>)

Примеры:

<pre><code>CREATE TABLE IF NOT EXISTS table_name (
    user_id serial PRIMARY KEY,
    username VARCHAR ( 50 ) NOT NULL,
    last_login TIMESTAMP
);</code></pre>
<pre><code>ALTER TABLE old_table_name RENAME TO new_table_name;</code></pre><hr>


<h3 id="6">6. DML. Ключевые операторы. Примеры.</h3>

<b>Data Manipulation Language (DML)</b> – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.

<b>Ключевые операторы:</b>
* SELECT – выборка данных
* INSERT – вставка новых данных
* UPDATE – обновление данных
* DELETE – удаление данных
* MERGE – слияние данных

Примеры:

<pre><code>INSERT INTO Product
SET maker = 'B',
    model = 1157,
    type = 'PC';</code></pre>
<pre><code>INSERT INTO Product_D(maker, model, type) VALUES
('B', 1158, 'PC'),
('C', 2190, 'Laptop'),
('D', 3219, 'Printer');
</code></pre>

<hr><h3 id="7">7. Что такое инфологическая и даталогическая модели бд.</h3>

<b>Инфологическая модель:</b>
* обобщенное представление предметной области;
* собирается на основе анализа пользовательских представлений;
* не зависит от «физического» хранилища;
* есть стандартные средства для описания (например, ER-диаграмма);

Пример:
<p align="center"><img src="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/blob/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/1/%D0%98%D0%BD%D1%84%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png"></p>

<b>Даталогическая модель:</b>
* строится по инфологической модели 
* содержит структуру таблиц с указанием типов данных и связей между
таблицами
* учитывает реальные возможности организации данных средствами выбранной СУБД

Пример:
<p align="center"><img src="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/blob/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5/1/%D0%94%D0%B0%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png"></p>

Для описания используется <a href="#3">модель "Сущность-Связь"</a>.

<b>Отображение ER-диаграмм в БД:</b>
* Сущность — таблица
* Экземпляр сущности — строка таблицы
* Атрибут — столбец в таблице
* Связь — внешний ключ, таблица
  
Связь «один-к-*»:
- Реализуется путем добавления в таблицу внешнего ключа.
- Внешний ключ обычно добавляется в сущностьассоциацию или в сущность-характеристику.
- Для моделирования характера связи на внешний ключ вводятся доп. ограничения (например, «один-кодному» - UNIQUE)

Связь «многие-ко-многим»:
- Для реализации связи вида «многие-ко-многим» создается вспомогательная таблица

Сайты для создания даталогических и инфологических моделей: 
* <a href="https://app.diagrams.net/" target="_blank">draw.io</a>
* <a href="https://dbdiagram.io/d" target="_blank">dbdiagram.io</a>

Как создать <a href="https://github.com/AlexPoluyanov/Information-Systems-and-Databases/tree/main/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5" target="_blank">даталогическую модель из DDL скрипта</a>.

<a href="https://ru.stackoverflow.com/questions/315124/%D0%9A%D0%B0%D0%BA-%D0%BE%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B8%D1%82%D1%8C-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-postgresql" target="_blank">Просмотр ER-диаграмм готовой бд.</a>

<hr><h3 id="8">8. Что такое Primary Key, Foreign Key. Что такое потенциальный ключ.</h3>

<b>Primary Key (PK, Первичный ключ)</b> - поле или набор полей со значениями, которые являются уникальными для всей таблицы.
- Ограничение первичного ключа эквивалентно комбинации ограничений UNIQUE и NOT NULL
- Таблица может иметь не более одного первичного ключа.
- Никакое поле нельзя удалить из ключа, неарушая при этом свойства однозначной идентификации записи (отсутствие избыточности)
- Добавление первичного ключа автоматически создает уникальный b-tree индекс на колонку (PostgreSQL)
- PostgreSQL позволяет не создавать первичный ключ для таблицы (согласно теории требуется наличие первичного ключа для каждой таблицы).

Примеры создания:
<pre><code>CREATE TABLE employees (
    employee_id serial PRIMARY KEY,
    first_name varchar(50),
    last_name varchar(50)
);</code></pre>

<pre><code>ALTER TABLE employees
ADD PRIMARY KEY (employee_id);
</code></pre>

<pre><code>CREATE TABLE orders (
    order_id serial,
    customer_id integer,
    order_date date,
    PRIMARY KEY (order_id, customer_id)
);</code></pre>

<pre><code>CREATE TABLE products (
    product_id serial,
    product_name varchar(100),
    CONSTRAINT pk_products PRIMARY KEY (product_id)
);</code></pre>


<b>Foreign Key (FK, Внешний ключ)</b> - столбец (или несколько столбцов), ссылающийся на первичный ключ другой таблицы.
- Если сущность связывает две другие сущности, то она должна включать внешние ключи, соответствующие первичным ключам связываемых сущностей.
- Если одна сущность характеризует другую сущность, то она должна включать внешний ключ, соответствующий первичному ключу первой сущности

Примеры создания:
<pre><code>CREATE TABLE Orders(
    Id SERIAL PRIMARY KEY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);</code></pre>

<pre><code>ALTER TABLE orders
ADD CONSTRAINT fk_customer
FOREIGN KEY (customer_id)
REFERENCES customers(ID);</code></pre>
<pre><code>CREATE TABLE orders (
    order_id serial PRIMARY KEY,
    customer_id integer REFERENCES customers(customer_id)
);
</code></pre>

<b>Candidate key (потенциальный ключ)</b> - представляет собой столбец (или несколько столбцов), которые могут стать первичным ключем, должны удовлетворять ряду условий:
- Неприводимость: он не может быть сокращен, он содержит минимально возможный набор атрибутов
- Уникальность (UNIQUE): он должен иметь уникальные значения вне зависимости от изменения строки
- Наличие значения (NOT NULL): он не должен иметь значения NULL, то есть он обязательно должен иметь значение.
Если у нас есть несколько потенциальных ключей, то те потенциальные ключи, которые не составляют первичный ключ, являются альтернативными ключами (alternative key).

<b>Особенности удаления FK.</b>

Внешние ключи существуют для обеспечения ссылочной целостности в базе данных. Это означает, что они гарантируют, что значения в столбце, связанном с внешним ключом, всегда ссылаются на существующие записи в связанной таблице. Поэтому удаление внешнего ключа может потребовать дополнительных действий для сохранения целостности данных.

При удалении записей из связанной таблицы, которые имеют связи через внешний ключ, СУБД может выполнить различные действия в зависимости от настроек внешнего ключа. Наиболее распространенные действия включают в себя:
- CASCADE: Удаление связанных записей в дочерней таблице, когда родительская запись удаляется.
- SET NULL: Установка значений в столбце с внешним ключом на NULL, когда родительская запись удаляется.
- SET DEFAULT: Установка значений в столбце с внешним ключом на значения по умолчанию, когда родительская запись удаляется.
- NO ACTION (RESTRICT): Запрещение удаления родительской записи, если существуют связанные записи в дочерней таблице.
Если вы планируете удалить запись из таблицы, учитывайте порядок операций. Сначала убедитесь, что вы удаляете записи из дочерних таблиц (если необходимо), а затем удаляйте запись из родительской таблицы. Это поможет избежать ошибок целостности данных.

Пример удаления FK:
<pre><code>ALTER TABLE orders
DROP CONSTRAINT fk_customer;
</code></pre>

Пример запроса который может вызвать ошибку ссылочной целостности по FK:
<pre><code>-- Попытаемся удалить клиента с активными заказами
DELETE FROM customers
WHERE customer_id = 1;
</code></pre>

<hr><h3 id="9">9. Плюсы и минусы использования суррогатных и естественных ключей. Cоставные ключи.</h3>

<b>Составной ключ</b> - представляет собой ключ, который состоит из двух или более атрибутов (полей), которые в совокупности однозначно идентифицируют записи в таблице.

<b>Суррогатный ключ</b> - это генерируемое системой (может быть GUID, последовательность, уникальный идентификатор и т.д.) значение, не имеющее смысла в терминах предметной области и которое используется для однозначной идентификации записи в таблице. Сам ключ может быть составлен из одного или большего числа столбцов (т.е. составной ключ). Пример: id.

<b>Естественный ключ</b> - это столбец или множество столбцов, которые уже существуют в таблице (например, это атрибуты сущности в модели данных) и однозначно идентифицируют запись в таблице. Поскольку эти столбцы являются атрибутами сущности, они очевидно имеют смысл в предметной области. Пример: Серия и номер паспорта, номер машины.

<b>Плюсы использования естественного ключа:</b>
- Значения ключа имеют смысл в предметной области и могут использоваться в качестве поискового ключа в запросах к таблице.
- Столбцы и индекс на первичном ключе уже существуют, поэтому не нужно дополнительного пространства на диске для дополнительного столбца/индекса, которые бы могли использоваться для суррогатного ключа.
- Меньше соединений таблиц, поскольку столбцы соединения имеют смысл. Например, это может уменьшить число дисковых операций ввода/вывода для выполнения избыточных чтений справочной таблицы.

<b>Минусы использования естественного ключа:</b>
- Может потребоваться поменять/переделать ключ, если изменятся бизнес-требования.
- Сложней обслуживать, если ключ состоит их нескольких столбцов. Со стороны приложений много проще работать с единственным ключевым столбцом
- Ухудшение производительности, поскольку значение ключа обычно больше по величине и/или состоит из нескольких столбцов. БОльшие ключи потребуют больше операций ввода/вывода при вставке/обновлении данных, а также при выборке.
- Нельзя ввести запись, если ключевое значение неизвестно. Приложениям иногда приходится загружать запись-заполнитель в одну таблицу, затем загружать в другие таблицы, после чего возвращаться и обновлять главную таблицу.
- Иногда трудно выбрать хороший ключ. Могут иметься несколько кандидатов для ключа, каждый со своими компромиссами с точки зрения проектирования и производительности.

<b>Плюсы использования сурогатного ключа:</b>
- Никакой бизнес-логики такой ключ не несет, поэтому нет никаких изменений, связанных с бизнес-требованиями.
- Меньше кода, если поддерживать одну и ту же стратегию ключа по всем сущностям. Например, код приложения может быть повторно использован при ссылках на первичные ключи, если все они применяют последовательное целое.
- Лучше производительность, поскольку ключ меньших размеров. Требуется меньшее число дисковых операций ввода/вывода при доступе к индексам на базе единственного столбца с точки зрения оптимизации.
- Суррогатный ключ гарантированно уникален. Например, при перемещении данных между тестовыми системами вам не придется беспокоиться о дубликатах ключей, поскольку новый ключ будет генерироваться при вставке данных
- Если использовалась последовательность, то потребуется минимальная поддержка индекса, поскольку значение монотонно возрастает, что приводит к меньшей фрагментации индекса.

<b>Минусы использования сурогатного ключа:</b>
- Дополнительный столбец (столбцы) на суррогатный ключ потребуют дополнительного места на диске.
- Дополнительный столбец (столбцы) на суррогатный ключ потребуют лишних операций ввода/вывода при вставке/обновлении данных.
- Потребуется больше соединений таблиц с дочерними таблицами, поскольку сами ключи не имеют смысла.
- Можно получить дубликаты естественного ключа в таблице, если отсутствуют другие ограничения уникальности на естественных ключах.
- Трудно различить тестовые и производственные данные. Например, поскольку значения суррогатного ключа являются просто автоматически генерируемыми и не имеющими отношения к предметной области, трудно сказать, взял ли кто-то производственные данные и загрузил их в тестовую среду.
- Ключевые значения не имеют отношения к данным, поэтому технически схема нарушает требования 3НФ (т.е. нормализацию).

<b>! Важно !</b>

Если у вас есть искусственный ключ и вы не объявляете естественные ключи, когда они существуют, то оставляете последние незащищёнными:
<pre><code>CREATE TABLE cars (
  car_id bigserial NOT NULL,
  vin varchar(17) NOT NULL,
  year int NOT NULL,

  UNIQUE (car_id)
  -- нужно было добавить
  -- UNIQUE (vin)
);

-- К сожалению, это успешно выполнится
INSERT INTO cars (vin, year) VALUES
  ('1FTJW36F2TEA03179', 1996),
  ('1FTJW36F2TEA03179', 1997);</code></pre>

<a href="https://habr.com/ru/companies/oleg-bunin/articles/348172/" target="_blank">Подробнее про ключи</a>


<hr><h3 id="10">10. Агрегатные и скалярные функции. Определение, примеры и особенности.</h3>
<b>Агрегатные функции</b> - выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение.
Агрегатные функции часто используются с операторами GROUP BY и HAVING. Оператор GROUP BY группирует строки с одинаковыми значениями в одну строку. Оператор HAVING используется в качестве фильтра для запросов, в которых есть оператор GROUP BY.
С агрегатными функциями можно использовать ключевые слова DISTINCT и ALL.

Свойства агрегатных функций:
- <b>Игнорируют NULL-значения.</b> Исключение — функция COUNT(*).
- Все агрегатные функции детерминированы. Это значит, что для одинакового набора данных функции возвращают одинаковое значение.

Примеры:
- SUM(column): вычисляет сумму значений столбца
- MIN(column): вычисляет наименьшее значение
- MAX(column): вычисляет наибольшее значение
- AVG(column): вычисляет среднее значение
- COUNT(column): вычисляет количество строк в запросе

Примеры в SQL:
<pre><code>SELECT role, COUNT(*) number_of_empoyee FROM employees GROUP BY role;
</code></pre>
<pre><code>SELECT SUM(salary) AS total_salary FROM employees;</code></pre>

<b>Скалярные функции</b> - это функции, которые принимают набор входных параметров и возвращают единственное значение. Это могут быть функции для выполнения математических вычислений, обработки строк, дат и времени, агрегации и других операций. В предыдущем ответе, я привел примеры скалярных функций.
Примеры:
- ABS(x): возвращает абсолютное значение числа x.
- ROUND(x, d): округляет число x до d знаков после запятой.
- CAST(expression AS data_type): преобразует выражение в указанный тип данных.
- RANDOM(): возвращает случайное число между 0 и 1
- UPPER(str): преобразует строку str в верхний регистр.

Примеры в SQL:
<pre><code>SELECT sqrt(25);</code></pre>
<pre><code>SELECT UPPER('Привет, мир!');</code></pre>


<hr><h3 id="11">11. Что такое отношение, атрибут, заголовок, тело, кортеж.</h3>

 ![image](https://github.com/AlexPoluyanov/Information-Systems-and-Databases/assets/109956453/72318598-a076-410e-896e-fc6d33f3d60b)

<b>Отношение (Relation, Имя таблицы)</b>: 

В реляционных базах данных отношение - это абстрактное представление таблицы, которая хранит данные. Отношение состоит из строк и столбцов. Каждая строка представляет собой запись, а каждый столбец определяет атрибут, описывающий определенные характеристики данных.

<b>Атрибут (Attribute, Колонка, Столбец)</b>: 

Атрибут представляет собой столбец в отношении (таблице). Каждый атрибут определяет конкретное свойство или характеристику, которая хранится в отношении. Например, в таблице "Пользователи" атрибуты могут включать "Имя", "Возраст", "Электронная почта" и так далее.

<b>Заголовок (Header)</b>: 

Заголовок отношения - это первая строка или метаданные в таблице, которая содержит имена атрибутов (столбцов). Заголовок помогает идентифицировать, какие атрибуты содержатся в таблице и какие типы данных они могут хранить.

<b>Тело (Body)</b>: 

Тело таблицы (отношения) состоит из фактических данных, представленных в виде строк и столбцов. Каждая строка в теле таблицы содержит конкретную запись или кортеж, где каждый атрибут имеет свое значение.

<b>Кортеж (Tuple, Строка)</b>: 

Кортеж - это термин, используемый в контексте реляционных баз данных для обозначения одной записи или строки в отношении. Каждый кортеж содержит набор значений, соответствующих атрибутам таблицы.

<hr><h3 id="12">12. CRUD.</h3>
<p align="center"><img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE2YzU1OGE1YjI0MjcwMmM4ZTZkOGNkYmM1MDFiMDc1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d5b2770b94d93eef3cec056724cb89c0af890057ec6da4151a52a40c7b6e858e" height="70%"width="70%"></p>

![image](https://github.com/AlexPoluyanov/Information-Systems-and-Databases/assets/109956453/da1a7366-7541-403f-bab4-cd23b793bfdd)

C — Create («создать»): добавляем новую запись или ресурс в БД. В SQL реализуется командами CREATE и INSERT.

<b><a href="https://postgrespro.ru/docs/postgresql/16/sql-createtable" target="_blank">CREATE</a></b> 

CREATE используется для создания новых объектов в базе данных, таких как таблицы, индексы, представления, процедуры, функции и т. д. Команда CREATE может иметь разные вариации в зависимости от типа объекта, который вы хотите создать.

Важно понимать что CREATE используется при создании не только таблиц, а множжества объектов бд: 

![image](https://github.com/AlexPoluyanov/Information-Systems-and-Databases/assets/109956453/d13c4404-efda-45fc-9beb-e9e9f96f0cfa)

Примеры:

<pre><code>CREATE TYPE gender AS ENUM ('Male', 'Female', 'Other');</code></pre>
<pre><code>CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    hire_date DATE
);
</code></pre>
<pre><code>CREATE INDEX idx_employee_last_name ON employees (last_name);</code></pre><hr>


<b><a href="https://postgrespro.ru/docs/postgresql/16/sql-insert" target="_blank">INSERT</a></b>

INSERT используется для добавления новых записей (строк) в таблицу. Эта команда выполняет операцию вставки данных в таблицу. Синтаксис команды INSERT может немного различаться в зависимости от конкретной системы управления базами данных (СУБД), но общие элементы обычно остаются теми же.

<details>
  <summary>Подробнее</summary>
  <br>

  INSERT добавляет строки в таблицу. Эта команда может добавить одну или несколько строк, сформированных выражениями значений, либо ноль или более строк, выданных дополнительным запросом.
  
Имена целевых столбцов могут перечисляться в любом порядке. Если список с именами столбцов отсутствует, по умолчанию целевыми столбцами становятся все столбцы заданной таблицы; либо первые N из них, если только N столбцов поступает от предложения VALUES или запроса. Значения, получаемые от предложения VALUES или запроса, связываются с явно или неявно определённым списком столбцов слева направо.

Все столбцы, не представленные в явном или неявном списке столбцов, получат значения по умолчанию, если для них заданы эти значения, либо NULL в противном случае.

Если выражение для любого столбца выдаёт другой тип данных, система попытается автоматически привести его к нужному.

Операция INSERT с таблицами без уникальных индексов не блокируется параллельно выполняемыми операциями. В таблицах с уникальными индексами эта операция может блокироваться, если в параллельных сеансах выполняются действия, которые блокируют или изменяют строки, совпадающие с вставляемыми значениями в уникальном индексе; подробнее см. Раздел 64.5. Предложение ON CONFLICT позволяет задать действие, заменяющее возникновение ошибки при нарушении ограничения уникальности или ограничения-исключения. (См. описание Предложение ON CONFLICT ниже.)

С необязательным предложением RETURNING команда INSERT вычислит и возвратит значения для каждой фактически добавленной строки (или изменённой, если применялось предложение ON CONFLICT DO UPDATE). В основном это полезно для получения значений, присвоенных по умолчанию, например, последовательного номера записи. Однако в этом предложении можно задать любое выражение со столбцами таблицы. Список RETURNING имеет тот же синтаксис, что и список результатов SELECT. В результате будут возвращены те строки, которые были успешно вставлены или изменены. Например, если строка была заблокирована, но не изменена, из-за того, что условие в предложении ON CONFLICT DO UPDATE ... WHERE не удовлетворено, эта строка возвращена не будет.

Чтобы добавлять строки в таблицу, необходимо иметь право INSERT для неё. Если присутствует предложение ON CONFLICT DO UPDATE, также требуется иметь право UPDATE для этой таблицы.

Если указывается список столбцов, достаточно иметь право INSERT только для перечисленных столбцов. Аналогично, с предложением ON CONFLICT DO UPDATE достаточно иметь право UPDATE только для столбцов, которые будут изменены. Однако предложение ON CONFLICT DO UPDATE также требует наличия права SELECT для всех столбцов, значения которых считываются в выражениях ON CONFLICT DO UPDATE или в условии.

Для применения предложения RETURNING требуется право SELECT для всех столбцов, перечисленных в RETURNING. Если для добавления строк применяется запрос, для всех таблиц или столбцов, задействованных в этом запросе, разумеется, необходимо иметь право SELECT.
</details>

Примеры:

<pre><code>INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');
</code></pre>
<pre><code>INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
</code></pre>
<pre><code>INSERT INTO new_employees (first_name, last_name, hire_date)
SELECT first_name, last_name, hire_date
FROM old_employees
WHERE hire_date >= '2023-01-01';
</code></pre>
<pre><code>INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;</code></pre><hr>


R — Read («прочитать»): получаем данные из базы данных или ресурса. В SQL реализуется командамой SELECT.

<b><a href="https://postgrespro.ru/docs/postgresql/16/sql-select" target="_blank">SELECT</a></b>

SELECT используется для выполнения операции чтения данных из базы данных. Она позволяет выбрать определенные столбцы и строки из таблицы или нескольких таблиц в соответствии с заданными условиями. Команда "SELECT" позволяет извлекать информацию из базы данных и представлять результат в виде результирующего набора данных, который может быть использован для анализа, отображения или дальнейшей обработки данных.

<details>
  <summary>Подробнее</summary>
  <br>

SELECT получает строки из множества таблиц (возможно, пустого). Общая процедура выполнения SELECT следующая:

Выполняются все запросы в списке WITH. По сути они формируют временные таблицы, к которым затем можно обращаться в списке FROM. Запрос в WITH без указания NOT MATERIALIZED выполняется только один раз, даже когда он фигурирует в списке FROM неоднократно.

Вычисляются все элементы в списке FROM. (Каждый элемент в списке FROM представляет собой реальную или виртуальную таблицу.) Если список FROM содержит несколько элементов, они объединяются перекрёстным соединением. 

Если указано предложение WHERE, все строки, не удовлетворяющие условию, исключаются из результата.

Если присутствует указание GROUP BY, либо в запросе вызываются агрегатные функции, вывод разделяется по группам строк, соответствующим одному или нескольким значениям, а затем вычисляются результаты агрегатных функций. Если добавлено предложение HAVING, оно исключает группы, не удовлетворяющие заданному условию.

Вычисляются фактические выходные строки по заданным в SELECT выражениям для каждой выбранной строки или группы строк. 

SELECT DISTINCT исключает из результата повторяющиеся строки. SELECT DISTINCT ON исключает строки, совпадающие по всем указанным выражениям. SELECT ALL (по умолчанию) возвращает все строки результата, включая дубликаты. 

Операторы UNION, INTERSECT и EXCEPT объединяют вывод нескольких команд SELECT в один результирующий набор. Оператор UNION возвращает все строки, представленные в одном, либо обоих наборах результатов. Оператор INTERSECT возвращает все строки, представленные строго в обоих наборах. Оператор EXCEPT возвращает все строки, представленные в первом наборе, но не во втором. Во всех трёх случаях повторяющиеся строки исключаются из результата, если явно не указано ALL. Чтобы явно обозначить, что выдаваться должны только неповторяющиеся строки, можно добавить избыточное слово DISTINCT. Заметьте, что в данном контексте по умолчанию подразумевается DISTINCT, хотя в самом SELECT по умолчанию подразумевается ALL. 

Если присутствует предложение ORDER BY, возвращаемые строки сортируются в указанном порядке. В отсутствие ORDER BY строки возвращаются в том порядке, в каком системе будет проще их выдать. 

Если указано предложение LIMIT (или FETCH FIRST) либо OFFSET, оператор SELECT возвращает только подмножество строк результата. 

Если указано FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE или FOR KEY SHARE, оператор SELECT блокирует выбранные строки, защищая их от одновременных изменений. 

Для всех столбцов, задействованных в команде SELECT, необходимо иметь право SELECT. Применение блокировок FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE или FOR KEY SHARE требует также права UPDATE (как минимум для одного столбца в каждой выбранной для блокировки таблице).
</details>


Примеры:

<pre><code>SELECT 2+2;</code></pre>
<pre><code>SELECT first_name, last_name, department, salary
FROM employees
WHERE department = 'Sales'
  AND salary > 50000
ORDER BY last_name ASC;
</code></pre>
<pre><code>SELECT Count(*) AS DistinctCountries
FROM (SELECT DISTINCT Country FROM Customers);</code></pre>
<pre><code>SELECT 2+2;</code></pre><hr>

U — Update («обновить»): меняем существующую запись. В SQL реализуется командамой UPDATE.

<b><a target="_blank" href="https://postgrespro.ru/docs/postgresql/16/sql-update">UPDATE</a></b>

UPDATE используется для изменения существующих записей в таблице базы данных. Эта команда позволяет обновлять данные в одной или нескольких строках таблицы в соответствии с заданными условиями.

<details>
  <summary>Подробнее</summary>
  <br>
  
UPDATE изменяет значения указанных столбцов во всех строках, удовлетворяющих условию. В предложении SET должны указываться только те столбцы, которые будут изменены; столбцы, не изменяемые явно, сохраняют свои предыдущие значения.

Изменить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя способами: применяя вложенные запросы или указав дополнительные таблицы в предложении FROM. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.

Предложение RETURNING указывает, что команда UPDATE должна вычислить и возвратить значения для каждой фактически изменённой строки. Вычислить в нём можно любое выражение со столбцами целевой таблицы и/или столбцами других таблиц, упомянутых во FROM. При этом в выражении будут использоваться новые (изменённые) значения столбцов таблицы. Список RETURNING имеет тот же синтаксис, что и список результатов SELECT.

Для выполнения этой команды необходимо иметь право UPDATE для таблицы, или как минимум для столбцов, перечисленных в списке изменяемых. Также необходимо иметь право SELECT для всех столбцов, значения которых считываются в выражениях или условии.

</details>

Примеры:

<pre><code>UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';</code></pre>
<pre><code>UPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)
  WHERE city = 'Tashkent' AND date = '2023-07-03';</code></pre>
<pre><code>UPDATE accounts SET (contact_first_name, contact_last_name) =
    (SELECT first_name, last_name FROM employees
     WHERE employees.id = accounts.sales_person);</code></pre><hr>


D — Delete («удалить»): удаляем запись или ресурс из базы данных. В SQL реализуется командамой DELETE и DROP.

<b><a target="_blank" href="https://postgrespro.ru/docs/postgresql/16/sql-delete">DELETE</a></b>

Команда DELETE удаляет из указанной таблицы строки, удовлетворяющие условию WHERE. Если предложение WHERE отсутствует, она удаляет из таблицы все строки, в результате будет получена рабочая, но пустая таблица.

<b>! Важно !</b>
<pre>TRUNCATE реализует более быстрый механизм удаления всех строк из таблицы.</pre>

<details>
  <summary>Подробнее</summary>
  <br>
  
Удалить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя способами: применяя вложенные запросы или указав дополнительные таблицы в предложении USING. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.

Предложение RETURNING указывает, что команда DELETE должна вычислить и возвратить значения для каждой фактически удалённой строки. Вычислить в нём можно любое выражение со столбцами целевой таблицы и/или столбцами других таблиц, упомянутых в USING. Список RETURNING имеет тот же синтаксис, что и список результатов SELECT.

Чтобы удалять данные из таблицы, необходимо иметь право DELETE для неё, а также право SELECT для всех таблиц, перечисленных в предложении USING, и таблиц, данные которых считываются в условии.
</details>

Примеры:

<pre><code>-- Удаление завершённых задач с получением всех данных удалённых строк;
  DELETE FROM tasks WHERE status = 'DONE' RETURNING *;</code></pre>
<pre><code>-- Удаление из tasks строки, на которой в текущий момент располагается курсор c_tasks
DELETE FROM tasks WHERE CURRENT OF c_tasks;</code></pre>
<pre><code>DELETE FROM films;</code></pre>
<pre><code>TRUNCATE TABLE crashes CASCADE;</code></pre><hr>

<b><a target="_blank" href="https://postgrespro.ru/docs/postgresql/16/sql-droptable">DROP</a></b>

DROP используется для удаления объектов, таких как таблицы, индексы, базы данных, представления и т. д. в базе данных. Конкретный синтаксис и возможности команды DROP зависят от СУБД (системы управления базами данных), которую вы используете. 

Важно понимать что DROP используется при удалении не только таблиц, а множжества объектов бд: 
![image](https://github.com/AlexPoluyanov/Information-Systems-and-Databases/assets/109956453/ad1a2a2a-53ac-4be9-abba-327ec69469aa)

Примеры:

<pre><code>DROP TABLE films, distributors;</code></pre>
<pre><code>-- Удаление всех таблиц, имена которых начинаются с определенного префикса;
  
DROP TABLE IF EXISTS
  (SELECT table_name
   FROM information_schema.tables
   WHERE table_name LIKE 'prefix_%');
</code></pre>
<pre><code>-- Удаление всех индексов, содержащих определенное ключевое слово в их названии;
  
SELECT indexname
INTO TEMP my_indexes
FROM pg_indexes
WHERE indexname LIKE '%ключевое_слово%';

DO $$
DECLARE
    index_name text;
BEGIN
    FOR index_name IN (SELECT indexname FROM my_indexes)
    LOOP
        EXECUTE 'DROP INDEX ' || index_name;
    END LOOP;
END $$;
</code></pre>
<pre><code>-- Удаление всех индексов, созданных более года назад
  
DO $$ 
DECLARE 
    index_name text;
BEGIN 
    FOR index_name IN (SELECT indexname FROM pg_indexes WHERE indexname NOT LIKE 'pg_%' AND indexname NOT LIKE 'idx_%' AND indexname NOT LIKE 'unique_%' AND indexname NOT LIKE 'fki_%' AND indexname NOT LIKE 'pkey_%' AND indexname NOT LIKE 'gin_%' AND indexname NOT LIKE 'gist_%' AND indexname NOT LIKE 'spgist_%' AND indexname NOT LIKE 'brin_%' AND indexname NOT LIKE 'hash_%' AND indexname NOT LIKE 'rsm_%' AND indexname NOT LIKE 'btree_%' AND indexname NOT LIKE 'name_%' AND indexname NOT LIKE 'seq_%' AND indexname NOT LIKE 'int4_%' AND indexname NOT LIKE 'int8_%')
    LOOP
        IF current_date - pg_indexes.indexdef -> 'created'::text::date > 365 THEN
            EXECUTE 'DROP INDEX IF EXISTS ' || index_name;
        END IF;
    END LOOP;
END $$;
</code></pre><hr>

<hr><h3 id="13">13. </h3>
<hr><h3 id="14">14. </h3>
<hr><h3 id="15">15. В чем отличие CHAR(), VARCHAR(), text.</h3>
<table>
  <caption>Символьные типы данных</caption>
  <tr><th>
    Имя
  </th><th>
    Описание
  </th></tr>
  <tr><td>
    character varying(n), varchar(n)	
  </td><td>строка ограниченной переменной длины
  </td></tr>
  <tr><td>
    character(n), char(n), bpchar(n)	
  </td><td>
    строка фиксированной длины, дополненная пробелами
  </td></tr>
  <tr><td>
    text
  </td><td>
    строка неограниченной переменной длины
  </td></tr>

<b>CHAR(N)</b>

Этот тип всегда имеет ограничение по длине. Даже, если длина не задана (char), то подразумевается, что она равна единице, то есть char ~ char(1).

Тип имеет одну особенность, которая выделяет есть среди других текстовых типов. Так как поля с этим типом имеют фиксированный размер (не больше / не меньше заданного), то, при сохранении в таблицу у всех строк, длина которых меньше этого размера, оставшееся пустое место в конце строки заполняется пробелами. Поэтому при сохранении значения '123' в поле с типом char(6) в таблицу реально сохранится '123___'. Это может стать неприятным сюрпризом.

Пример:
<pre><code>CREATE TABLE NAME(
name char(6) PRIMARY KEY,
surname char(10))

INSERT INTO NAME VALUES
('123456', '12345')

SELECT (SELECT surname FROM NAME) = '12345         '

-- Return: True
</code></pre>

<b>VARCHAR</b>

Тип без заданной длины интерпретируется PostgreSQL, как безразмерная строка эквивалентная типу text. При попытке записать в текстовое поле ограниченной длины значение, которое превышает заданные размеры, генерируется ошибка. Строка этого типа хранится в базе данных без изменений (в отличии от char(n)), поэтому нагрузка на процессор при обработке varchar-строк немного меньше, чем при работе с char(n).

При операциях сравнения полей с типом char(n) пробелы в конце строки игнорируются.

Пример:
<pre><code>CREATE TABLE NAME(
name varchar(6) PRIMARY KEY,
surname varchar(10))

INSERT INTO NAME VALUES
('123456', '12345')

SELECT (SELECT surname FROM NAME) = '12345         '

-- Return: False
</code></pre>

<b>TEXT</b>

Этот тип позволяет сохранять строки размером до одного гигабайта. Поэтому его часто используют для хранения текстов, html-страниц и прочей тестовой информации размер которой превышает одну строку текста.

Пример:
<pre><code>CREATE TABLE NAME(
name text PRIMARY KEY,
surname text)

INSERT INTO NAME VALUES
('123456', '12345')

SELECT (SELECT surname FROM NAME) = '12345      '

-- Return: False
</code></pre>

<b>! Важно !</b>

По быстродействию эти три типа практически не отличаются друг от друга, не считая большего размера хранения для типа с дополняющими пробелами и нескольких машинных операций для проверки длины при сохранении строк в столбце с ограниченной длиной. Хотя в некоторых СУБД тип character(n) работает быстрее других, в PostgreSQL это не так; на деле character(n) обычно оказывается медленнее остальных типов из-за большего размера данных и более медленной сортировки. В большинстве случаев вместо него лучше применять text или character varying.

<details>
  <summary>
    Подробнее про символьные типы данных
  </summary><br>

SQL определяет два основных символьных типа: character varying(n) и character(n), где n — положительное число. Оба эти типа могут хранить текстовые строки длиной до n символов (не байт). Попытка сохранить в столбце такого типа более длинную строку приведёт к ошибке, если только все лишние символы не являются пробелами (тогда они будут усечены до максимально допустимой длины). (Это несколько странное исключение продиктовано стандартом SQL.) Однако если явно привести значение к типу character varying(n) или character(n), то слишком длинное значение будет усечено до n символов без возникновения ошибки. (Это также является требованием стандарта SQL.) Если длина сохраняемой строки оказывается меньше объявленной, значения типа character будут дополнятся пробелами, а тип character varying просто сохранит короткую строку.

Помимо этого, PostgreSQL предлагает тип text, в котором можно хранить строки произвольной длины. Хотя тип text не описан в стандарте SQL, его поддерживают и некоторые другие СУБД SQL. Тип text — это встроенный строковый тип данных PostgreSQL, и большинство встроенных функций, работающих со строками, объявляются принимающими или возвращающими text, а не character varying. Во многих случаях character varying действует так, как если бы это был домен поверх text.

Имя типа varchar является псевдонимом для character varying, а char и bpchar — для character. Псевдонимы varchar и char определены в стандарте SQL, но bpchar — это расширение PostgreSQL.

Если n задано, оно должно быть больше нуля и меньше или равно 10485760. Записи character без указания длины соответствует character(1). Если же длина не указывается для character varying, этот тип будет принимать строки любого размера.

Значения типа character физически дополняются пробелами до n символов и хранятся, а затем отображаются в таком виде. Однако при сравнении двух значений типа character дополняющие пробелы считаются незначащими и игнорируются. С правилами сортировки, где пробельные символы являются значащими, это поведение может приводить к неожиданным результатам, например SELECT 'a '::CHAR(2) collate "C" < E'a\n'::CHAR(2) вернёт true (условие будет истинным), хотя в локали C символ пробела считается больше символа новой строки. При приведении значения character к другому символьному типу дополняющие пробелы отбрасываются. Заметьте, что эти пробелы несут смысловую нагрузку в типах character varying и text и в проверках по шаблонам, то есть в LIKE и регулярных выражениях.

Какие именно символы можно сохранить в этих типах данных, зависит от того, какой набор символов был выбран при создании базы данных. Однако символ с кодом 0 (иногда называемый NUL) сохранить нельзя, вне зависимости от выбранного набора символов.

Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт плюс размер самой строки, включая дополняющие пробелы для типа character. Для строк длиннее требуется не 1, а 4 дополнительных байта. Система может автоматически сжимать длинные строки, так что физический размер на диске может быть меньше. Очень длинные текстовые строки переносятся в отдельные таблицы, чтобы они не замедляли работу с другими столбцами. В любом случае максимально возможный размер строки составляет около 1 ГБ. (Допустимое значение n в объявлении типа данных меньше этого числа. Это объясняется тем, что в зависимости от кодировки каждый символ может занимать несколько байт. Если вы желаете сохранять строки без определённого предела длины, используйте типы text или character varying без указания длины, а не задавайте какое-либо большое максимальное значение.)
</details>


<hr><h3 id="16">16. </h3>
<hr><h3 id="17">17. </h3>
<hr><h3 id="18">18. </h3>
<hr><h3 id="19">19. </h3>
<hr><h3 id="20">20. </h3>
<hr><h3 id="21">21. </h3>
<hr><h3 id="22">22. </h3>


